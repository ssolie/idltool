# This script is a codegen module for idltool.py.
#
# gen_vector_files.py - Generates <libname>_vectors.[c|h] files
# Copyright (C) 2021 Steven Solie
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>

class VectorsTable:
	""" Code generator to create library interface vectors table.
	"""
	def __init__(self, spec_file):
		self.spec_file  = spec_file
		self.out_file   = None
		self.h_out_file = None
		self.c_out_file = None

	def codegen(self, tool_version, out_dir):
		""" Code generate the vectors table files.
		"""
		import os

		lib_spec = self.spec_file.library_spec()
		lib_name = lib_spec.attrib["name"]

		try:
			os.makedirs(out_dir)
		except:
			pass

		h_name = lib_name + '_vectors.h'
		h_path = os.path.join(out_dir, h_name)
		c_path = os.path.join(out_dir, lib_name + '_vectors.c')

		self.h_out_file = open(h_path, "w+")
		self.c_out_file = open(c_path, "w+")

		self.codegen_h(tool_version)
		self.codegen_c(h_name, tool_version)

		self.h_out_file.close()
		self.c_out_file.close()

	def codegen_h(self, tool_version):
		self.out_file = self.h_out_file

		self.put_header(tool_version)
		self.put_includes()
		self.putln()

		for iface_spec in self.spec_file.interfaces_spec():
			struct_name = iface_spec.attrib['struct']

			self.putln()
			self.putln('/* forward declaration */')
			self.putln('struct ' + struct_name + ';')
			self.putln()

			prefix_name = iface_spec.attrib['prefix']

			for method in iface_spec:
				method_status = method.get('status')
				if method_status == 'unimplemented':
					# Do not output unimplemented method.
					continue

				method_name   = method.attrib['name']
				method_result = method.attrib['result']

				method_lifecycle = method.get('lifecycle')
				if method_lifecycle == 'deprecated':
					method_result = 'DEPRECATED ' + method_result

				self.put('extern ' + method_result + ' VARARGS68K ' + prefix_name + method_name)
				self.put('(struct ' + struct_name + ' *')
				self.put_method_args(method)
				self.putln(');')

			self.putln()

	def codegen_c(self, h_filename, tool_version):
		self.out_file = self.c_out_file

		self.put_header(tool_version)
		self.putln('#include "' + h_filename + '"')

		for iface_spec in self.spec_file.interfaces_spec():
			prefix_name   = iface_spec.attrib['prefix']
			struct_name   = iface_spec.attrib['struct']
			iface_name    = iface_spec.attrib['name']
			iface_version = iface_spec.attrib['version'][0]

			self.putln()
			self.putln('STATIC uint32 VARARGS68K ' + prefix_name + 'UNIMPLEMENTED(struct ' + struct_name + ' *iface UNUSED)')
			self.putln('{')
			self.putln('  return 0;')
			self.putln('}')

			self.putln('STATIC CONST APTR ' + iface_name + '_v' + iface_version + '_vectors[] =')
			self.putln('{')

			for method_spec in iface_spec:
				method_name   = method_spec.attrib['name']
				method_status = method_spec.get('status')

				self.put('    ' + prefix_name)

				if method_status == 'unimplemented':
					self.putln('UNIMPLEMENTED, /* ' + method_name + ' */')
				else:
					self.putln(method_name + ',')

			self.putln('    (APTR)-1')
			self.putln('};')

	def put(self, line=''):
		self.out_file.write(line)

	def putln(self, line=''):
		self.out_file.write(line + '\n')

	def put_header(self, tool_version):
		self.putln('/*')
		self.putln('** This file was machine generated by idltool.py ' + tool_version + '.')
		self.putln('** Do not edit.')

		copyright = self.spec_file.library_spec().find('copyright')
		if copyright != None:
			self.putln('**')
			self.putln('** ' + copyright.text.strip())
			self.putln('**')

		self.putln('*/')
		self.putln()

	def put_includes(self):
		self.putln('#include <exec/types.h>')
		self.putln('#include <exec/exec.h>')
		self.putln('#include <exec/interfaces.h>')

		for spec in self.spec_file.includes_spec():
			name = spec.text.strip()
			self.putln('#include <' + name + '>')

	def put_method_args(self, method_spec, is_gcc2=False):
		for arg_spec in method_spec.findall('arg'):
			self.put(', ')

			arg_name = arg_spec.attrib['name']
			arg_type = arg_spec.attrib['type']

			function_ptr = arg_type.find('(*)')
			if function_ptr != -1:
				self.put(arg_type[0:function_ptr - 1] + ' (*' + arg_name + ')()')
			else:
				self.put(arg_type + ' ' + arg_name)

		if method_spec.find('vararg') != None:
			self.put(', ...')
