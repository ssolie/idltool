# This script is a codegen module for idltool.py.
#
# gen_m68k_files.py - Generates M68K clib, pragma, pragmas and inline files
# Copyright (C) 2021 Steven Solie
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>

class M68KFiles:
	""" Code generator to create the necessary M68K files to call interface functions.
	"""
	def __init__(self, spec_file):
		self.spec_file = spec_file
		self.out_file  = None

	def codegen(self, tool_version, out_dir):
		""" Code generate the library interface file.
		"""
		import os

		lib_spec = self.spec_file.library_spec()
		lib_name = lib_spec.attrib["name"]

		# Verify there is m68k support before continuing.
		has_m68k_spec = False
		for iface_spec in self.spec_file.interfaces_spec():
			if iface_spec.attrib['name'] == 'main':
				if lib_spec.get('m68kbias') != None:
					has_m68k_spec = True

		if not has_m68k_spec:
			print('No M68K spec found')
			return

		clib_path    = os.path.join(out_dir, 'include', 'clib')
		inline_path  = os.path.join(out_dir, 'include', 'inline')
		pragma_path  = os.path.join(out_dir, 'include', 'pragma')
		pragmas_path = os.path.join(out_dir, 'include', 'pragmas')

		try:
			os.makedirs(clib_path)
			os.makedirs(inline_path)
			os.makedirs(pragma_path)
			os.makedirs(pragmas_path)
		except:
			pass

		clib_path    = os.path.join(clib_path, lib_name + '_protos.h')
		inline_path  = os.path.join(inline_path, lib_name + '.h')
		pragma_path  = os.path.join(pragma_path, lib_name + '_lib.h')
		pragmas_path = os.path.join(pragmas_path, lib_name + '_pragmas.h')

		self.clib_file    = open(clib_path, "w+")
		self.inline_file  = open(inline_path, "w+")
		self.pragma_file  = open(pragma_path, "w+")
		self.pragmas_file = open(pragmas_path, "w+")

		for iface_spec in self.spec_file.interfaces_spec():
			if iface_spec.attrib['name'] == 'main':
				self.put_clib_file(iface_spec, tool_version, lib_name)

				lib_basename = lib_spec.attrib['basename']
				lib_basetype = lib_spec.attrib['basetype']
				lib_bias     = int(lib_spec.attrib['m68kbias'])

				self.put_inline_file(iface_spec, tool_version, lib_name, lib_basename, lib_basetype, lib_bias)
				self.put_pragma_file(tool_version, lib_name)
				self.put_pragmas_file(iface_spec, tool_version, lib_name, lib_basename, lib_bias)

		self.clib_file.close()
		self.inline_file.close()
		self.pragma_file.close()
		self.pragmas_file.close()

	def put(self, line=''):
		self.out_file.write(line)

	def putln(self, line=''):
		self.out_file.write(line + '\n')

	def calc_m68k_function_offset(self, bias, slot):
		""" The offset if defined as (slot * 6) + 30 bytes from the library base
			when used on an M68K Amiga. The offest is always negative relative to a6.
		"""
		return (slot * 6) + bias

	def put_m68k_includes(self, iface_spec):
		for spec in self.spec_file.m68k_includes_spec():
			name = spec.text.strip()
			self.putln('#include <' + name + '>')

	def put_clib_file(self, iface_spec, tool_version, lib_name):
		self.out_file = self.clib_file

		guard_name = 'CLIB_' + lib_name.upper() + '_PROTOS_H'
		self.putln('#ifndef ' + guard_name)
		self.putln('#define ' + guard_name)
		self.putln()
		self.putln('/*')
		self.putln('** This file was machine generated by idltool.py ' + tool_version + '.')
		self.putln('** Do not edit.')

		copyright = self.spec_file.library_spec().find('copyright')
		if copyright != None:
			self.putln('**')
			self.putln('** ' + copyright.text.strip())

		self.putln('**')
		self.putln('** C prototypes. For use with 32 bit integers only.')
		self.putln('*/')
		self.putln()
		self.put_m68k_includes(iface_spec)
		self.putln()
		self.putln('#ifdef __amigaos4__')
		self.putln('#error Include <proto/> header files, not <clib/> header files in AmigaOS 4.')
		self.putln('#endif')
		self.putln()
		self.putln('#ifdef __cplusplus')
		self.putln('#ifdef __USE_AMIGAOS_NAMESPACE__')
		self.putln('namespace AmigaOS {')
		self.putln('#endif')
		self.putln('extern "C" {')
		self.putln('#endif /* __cplusplus */')
		self.putln()

		sorted_method_specs = []
		for method_spec in iface_spec:
			if method_spec.get('m68kslot') == None:
				# Skip non-m68k methods.
				continue

			sorted_method_specs.append(method_spec)

		sorted_method_specs.sort(key=lambda spec: int(spec.attrib['m68kslot']))

		for method_spec in sorted_method_specs:
			method_name   = method_spec.attrib['name']
			method_result = method_spec.attrib['result']

			self.put(method_result + ' ' + method_name + '(')

			# Filter out method arguments without a 68K register tag.
			method_args_spec = []
			for arg_spec in method_spec:
				if arg_spec.get('m68kreg') != None:
					method_args_spec.append(arg_spec)

			if len(method_args_spec) == 0:
				self.put('void')
			else:
				num_args = 0
				for arg_spec in method_args_spec:
					if num_args > 0:
						self.put(', ')

					arg_name = arg_spec.attrib['name']
					arg_type = arg_spec.attrib['type']

					function_ptr = arg_type.find('(*)')
					if function_ptr != -1:
						self.put(arg_type.split(' (')[0] + ' (*' + arg_name + ')()')
					else:
						self.put(arg_type + ' ' + arg_name)

					num_args += 1

			vararg_spec = method_spec.find('vararg')
			if vararg_spec != None:
				self.put(', ...')

			self.putln(');')

		self.putln()
		self.putln('#ifdef __cplusplus')
		self.putln('}')
		self.putln('#ifdef __USE_AMIGAOS_NAMESPACE__')
		self.putln('}')
		self.putln('#endif')
		self.putln('#endif /* __cplusplus */')
		self.putln()
		self.putln('#endif /* ' + guard_name + ' */')

	def put_inline_file(self, iface_spec, tool_version, lib_name, lib_basename, lib_basetype, lib_bias):
		self.out_file = self.inline_file

		LIB_NAME   = lib_name.upper()
		BASE_NAME  = LIB_NAME + '_BASE_NAME'
		guard_name = '_INLINE_' + LIB_NAME + '_H'

		self.putln('#ifndef ' + guard_name)
		self.putln('#define ' + guard_name)
		self.putln('/*')
		self.putln('** This file was machine generated by idltool.py ' + tool_version + '.')
		self.putln('** Do not edit.')

		copyright = self.spec_file.library_spec().find('copyright')
		if copyright != None:
			self.putln('**')
			self.putln('** ' + copyright.text.strip())

		self.putln('*/')
		self.putln()

		self.putln('#ifdef __amigaos4__')
		self.putln('#error Include <proto/> header files, not <inline/> header files in AmigaOS 4.')
		self.putln('#endif')
		self.putln()

		self.putln('#ifndef CLIB_' + LIB_NAME + '_PROTOS_H')
		self.putln('#define CLIB_' + LIB_NAME + '_PROTOS_H')
		self.putln('#endif')
		self.putln()
		self.put_m68k_includes(iface_spec)
		self.putln()
		self.putln('#ifndef ' + BASE_NAME)
		self.putln('#define ' + BASE_NAME + lib_basename)
		self.putln('#endif')
		self.putln()

		sorted_method_specs = []
		for method_spec in iface_spec:
			if method_spec.get('m68kslot') == None:
				# Skip all non-m68k methods.
				continue

			sorted_method_specs.append(method_spec)

		sorted_method_specs.sort(key=lambda spec: int(spec.attrib['m68kslot']))

		# Used for generating varargs macro which depends on the previous method.
		previous_method_name = None
		previous_method_args = []

		for method_spec in sorted_method_specs:
			method_name = method_spec.attrib['name']
			method_slot = int(method_spec.attrib['m68kslot'])

			method_result = method_spec.get('m68kresult')
			if method_result == None:
				method_result = method_spec.attrib['result']

			# Filter out method arguments without a 68K register tag.
			method_args = []
			for arg_spec in method_spec:
				if arg_spec.get('m68kreg') != None:
					method_args.append(arg_spec)

			# With varargs we define a macro based on the previous function's prototype.
			method_vararg_spec = method_spec.find('vararg')
			if method_vararg_spec != None:
				self.putln('#ifndef NO_INLINE_STDARG')
				self.put('static __inline__ ' + method_result + ' ___' + method_name + '(struct ' + lib_basetype + ' * ' + lib_basename)

				for arg_spec in method_args:
					arg_name = arg_spec.attrib['name']
					arg_type = arg_spec.attrib['type']
					self.put(', ' + arg_type + ' ' + arg_name)

				self.putln(', ...)')
				self.putln('{')
				self.put('  return ' + previous_method_name + '(')

				for i in range(len(previous_method_args) - 1):
					arg_spec = previous_method_args[i]
					arg_name = arg_spec.attrib['name']
					arg_type = arg_spec.attrib['type']
					self.put(arg_name + ', ')

				last_arg_spec = previous_method_args[-1]
				last_arg_type = last_arg_spec.attrib['type']

				# Tag lists are handled differently.
				if method_args[-1].attrib['type'] == 'Tag':
					self.putln('(' + last_arg_type + ') &' + method_args[-1].attrib['name'] + ');')
					self.putln('}')
					self.putln()
					self.put('#define ' + method_name + '(')
				else:
					second_last_arg_spec = previous_method_args[-2]
					second_last_arg_name = second_last_arg_spec.attrib['name']
					second_last_arg_type = second_last_arg_spec.attrib['type']
					self.putln('(' + last_arg_type + ') ((ULONG) &' + second_last_arg_name + ' + sizeof(' + second_last_arg_type + ')));')
					self.putln('}')
					self.putln()
					self.put('#define ' + method_name + '(')

				for i in range(len(method_args) - 1):
					arg_spec = method_args[i]
					if i > 0:
						self.put(', ')

					arg_name = arg_spec.attrib['name']
					self.put(arg_name)

				self.put('...)')
				self.put(' ___' + method_name + '(' + BASE_NAME)

				for i in range(len(method_args) - 1):
					arg_spec = method_args[i]
					arg_name = arg_spec.attrib['name']
					self.put(', ' + arg_name)

				self.putln(')')
				self.putln('#endif')
				self.putln()
				continue

			previous_method_name = method_name
			previous_method_args = method_args

			self.put('#define ' + method_name + '(')

			num_args = 0
			for arg_spec in method_args:
				if num_args > 0:
					self.put(', ')

				arg_name = arg_spec.attrib['name']
				self.put(arg_name)
				num_args += 1

			self.put(')')
			self.putln(' ({ \\')

			# Different code is generated if there is a return value.
			has_result = False
			if method_result.strip().lower() != 'void':
				has_result = True

			for arg_spec in method_args:
				arg_name = arg_spec.attrib['name']
				arg_type = arg_spec.attrib['type']
				arg_reg  = arg_spec.get('m68kreg')
				if arg_reg == None:
					# Skip args with no register specification.
					continue

				function_ptr = arg_type.find('(*)')
				if function_ptr != -1:
					self.putln('  ' + arg_type[0:function_ptr - 1] + ' (*_' + method_name + '_' + arg_name + ')() = (' + arg_name + '); \\')
				else:
					self.putln('  ' + arg_type + ' _' + method_name + '_' + arg_name + ' = (' + arg_name + '); \\')

			if has_result:
				self.putln('  ' + method_result + ' _' + method_name + '__re = \\')
				self.putln('  ({ \\')
			else:
				if num_args > 0:
					self.putln('  { \\')

			self.putln('  register struct ' + lib_basetype + ' * const __' + method_name + '__bn __asm("a6") = (struct ' + lib_basetype + ' *) (' + BASE_NAME + ');\\')

			if has_result:
				self.putln('  register ' + method_result + " __" + method_name + '__re __asm("d0"); \\')

			exg_reg = None

			for arg_spec in method_args:
				arg_name = arg_spec.attrib['name']
				arg_type = arg_spec.attrib['type']
				arg_reg  = arg_spec.attrib['m68kreg']

				arg_reg = arg_reg.lower()

				if arg_reg == 'a4' or arg_reg == 'a5':
					exg_reg = arg_reg
					arg_reg = 'd2'

				function_ptr = arg_type.find('(*)')
				if function_ptr != -1:
					self.putln('  register ' + arg_type.split(' (')[0] + ' (*__' + method_name + '_' + arg_name + ')() __asm("' + arg_reg + '") = (_' + method_name + '_' + arg_name + '); \\')
				else:
					self.putln('  register ' + arg_type + ' __' + method_name + '_' + arg_name + ' __asm("' + arg_reg + '") = (_' + method_name + '_' + arg_name + '); \\')

			method_offset = self.calc_m68k_function_offset(lib_bias, method_slot)
			if exg_reg == None:
				self.putln('  __asm volatile ("jsr a6@(-' + str(method_offset) + ':W)" \\')
			else:
				self.putln('  __asm volatile ("exg ' + exg_reg + ',d2\\n\\tjsr a6@(-' + str(method_offset) + ':W)\\n\\texg ' + exg_reg + ',d2" \\')

			if has_result:
				self.putln('  : "=r"(__' + method_name + '__re) \\')
			else:
				self.putln('  : \\')

			self.put('  : "r"(__' + method_name + '__bn)')

			for arg_spec in method_args:
				arg_name = arg_spec.attrib['name']
				self.put(', "r"(__' + method_name + '_' + arg_name + ')')

			self.putln(' \\')

			if has_result:
				self.putln('  : "d1", "a0", "a1", "fp0", "fp1", "cc", "memory"); \\')
				self.putln('  __' + method_name + '__re; \\')
				self.putln('  }); \\')
				self.putln('  _' + method_name + '__re; \\')
			else:
				self.putln('  : "d0", "d1", "a0", "a1", "fp0", "fp1", "cc", "memory"); \\')
				if num_args > 0:
					self.putln('  } \\')

			self.putln('})')
			self.putln()

		self.putln('#endif /*  ' + guard_name + '  */')

	def put_pragma_file(self, tool_version, lib_name):
		self.out_file = self.pragma_file

		LIB_NAME   = lib_name.upper()
		guard_name = 'PRAGMA_' + LIB_NAME + '_H'

		self.putln('#ifndef ' + guard_name)
		self.putln('#define ' + guard_name)
		self.putln('/*')
		self.putln('** This file was machine generated by idltool.py ' + tool_version + '.')
		self.putln('** Do not edit.')

		copyright = self.spec_file.library_spec().find('copyright')
		if copyright != None:
			self.putln('**')
			self.putln('** ' + copyright.text.strip())

		self.putln('**')
		self.putln('** Aztec `C\' style pragma header file wrapper')
		self.putln('**')
		self.putln('*/')
		self.putln()
		self.putln('#ifdef __amigaos4__')
		self.putln('#error Include <proto/> header files, not <pragma/> header files in AmigaOS 4.')
		self.putln('#endif')
		self.putln()
		self.putln('#ifndef   PRAGMAS_' + LIB_NAME + '_PRAGMAS_H')
		self.putln('#include <pragmas/' + lib_name + '_pragmas.h>')
		self.putln('#endif')
		self.putln()
		self.putln('#endif /* ' + guard_name + ' */')

	def put_pragmas_file(self, iface_spec, tool_version, lib_name, lib_basename, lib_bias):
		self.out_file = self.pragmas_file

		LIB_NAME   = lib_name.upper()
		guard_name = 'PRAGMAS_' + LIB_NAME + '_PRAGMAS_H'

		self.putln('#ifndef ' + guard_name)
		self.putln('#define ' + guard_name)
		self.putln('/*')
		self.putln('** This file was machine generated by idltool.py ' + tool_version + '.')
		self.putln('** Do not edit.')

		copyright = self.spec_file.library_spec().find('copyright')
		if copyright != None:
			self.putln('**')
			self.putln('** ' + copyright.text.strip())

		self.putln('**')
		self.putln('** Direct ROM interface (pragma) definitions.')
		self.putln('**')
		self.putln('*/')
		self.putln()
		self.putln('/*')
		self.putln(' * NOTE: These 68k platform specific #pragma header files are unlikely to see')
		self.putln(' *       further updates with the AmigaOS 4 update and following development')
		self.putln(' *       efforts. If you can, please switch to native PowerPC development.')
		self.putln(' */')
		self.putln('#ifdef __amigaos4__')
		self.putln('#error Include <proto/> header files, not <pragmas/> header files in AmigaOS 4.')
		self.putln('#endif')
		self.putln('#if defined(LATTICE) || defined(__SASC) || defined(_DCC)')
		self.putln('#ifndef __CLIB_PRAGMA_LIBCALL')
		self.putln('#define __CLIB_PRAGMA_LIBCALL')
		self.putln('#endif /* __CLIB_PRAGMA_LIBCALL */')
		self.putln('#else /* __MAXON__, __STORM__ or AZTEC_C */')
		self.putln('#ifndef __CLIB_PRAGMA_AMICALL')
		self.putln('#define __CLIB_PRAGMA_AMICALL')
		self.putln('#endif /* __CLIB_PRAGMA_AMICALL */')
		self.putln('#endif /* */')
		self.putln()
		self.putln('#if defined(__SASC) || defined(__STORM__)')
		self.putln('#ifndef __CLIB_PRAGMA_TAGCALL')
		self.putln('#define __CLIB_PRAGMA_TAGCALL')
		self.putln('#endif /* __CLIB_PRAGMA_TAGCALL */')
		self.putln('#endif /* __MAXON__, __STORM__ or AZTEC_C */')
		self.putln()
		self.putln('#ifndef CLIB_' + LIB_NAME + '_PROTOS_H')
		self.putln('#include <clib/' + lib_name + '_protos.h>')
		self.putln('#endif /* CLIB_' + LIB_NAME + '_PROTOS_H */')
		self.putln()

		sorted_method_specs = []
		for method_spec in iface_spec:
			if method_spec.get('m68kslot') == None:
				# Skip non-m68k methods.
				continue

			sorted_method_specs.append(method_spec)

		sorted_method_specs.sort(key=lambda spec: int(spec.attrib['m68kslot']))

		for method_spec in sorted_method_specs:
			if method_spec.get('m68kslot') == None:
				# Skip non-m68k methods.
				continue

			method_name = method_spec.attrib['name']
			method_slot = int(method_spec.attrib['m68kslot'])

			offset = self.calc_m68k_function_offset(lib_bias, method_slot)
			slot_hex = hex(offset)[2:]

			# This 68K register mapping was defined by the compiler provider
			# for use with pragmas.
			reg_map = {
				"d0": "0",
				"d1": "1",
				"d2": "2",
				"d3": "3",
				"d4": "4",
				"d5": "5",
				"d6": "6",
				"d7": "7",
				"a0": "8",
				"a1": "9",
				"a2": "A",
				"a3": "B",
				"a4": "C",
				"a5": "D",
				"a6": "E",
				"a7": "F",
			}

			reg_hex = ''

			num_args = 0
			for arg_spec in method_spec:
				arg_reg = arg_spec.get('m68kreg')
				if arg_reg == None:
					# Skip args with no register.
					continue

				reg_hex = reg_map[arg_reg.lower()] + reg_hex
				num_args += 1

			reg_hex += reg_map['d0']  # Result is always in reg d0
			reg_hex += str(num_args)

			if method_spec.find('vararg') != None:
				self.putln('#ifdef __CLIB_PRAGMA_TAGCALL')
				self.putln(' #ifdef __CLIB_PRAGMA_LIBCALL')
				self.putln('  #pragma tagcall ' + lib_basename + ' ' + method_name + ' ' + slot_hex + ' ' + reg_hex)
				self.putln(' #endif /* __CLIB_PRAGMA_LIBCALL */')
				self.putln('#endif /* __CLIB_PRAGMA_TAGCALL */')
			else:
				self.putln('#ifdef __CLIB_PRAGMA_LIBCALL')
				self.putln(' #pragma libcall ' + lib_basename + ' ' + method_name + ' ' + slot_hex + ' ' + reg_hex)
				self.putln('#endif /* __CLIB_PRAGMA_LIBCALL */')

		self.putln()
		self.putln('#endif /* ' + guard_name + ' */')
